<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Archon.SwissArmyLib</name>
    </assembly>
    <members>
        <member name="T:Archon.SwissArmyLib.Automata.IPdaState`1">
            <summary>
            Represents a state to be used in a <see cref="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1"/>.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IPdaState`1.Pause">
            <summary>
            Called when a state is pushed ontop of this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IPdaState`1.Resume">
            <summary>
            Called when the state above us is popped.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.IState`2">
            <summary>
            Represents a state to be used in a state machine.
            
            You might be looking for <see cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/> or <see cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/>.
            </summary>
            <typeparam name="TMachine">The type of the machine.</typeparam>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.IState`2.Machine">
            <summary>
            The state machine this state belongs to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.IState`2.Context">
            <summary>
            The context for this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Begin">
            <summary>
            Called when the state is entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Reason">
            <summary>
            Called every frame just before <see cref="M:Archon.SwissArmyLib.Automata.IState`2.Act(System.Single)"/>. 
            Use this to check whether you should change state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Act(System.Single)">
            <summary>
            Called every frame after <see cref="M:Archon.SwissArmyLib.Automata.IState`2.Reason"/>, if the state hasn't been changed.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.End">
            <summary>
            Called when the state is exited.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.PdaState`1">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/> and can be used in a <see cref="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1"/>
            
            You're not required to use this, but it's easier.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PdaState`1.Pause">
            <summary>
            Called when a state is pushed ontop of this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PdaState`1.Resume">
            <summary>
            Called when the state above us is popped.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1">
             <summary>
             A simple <see href="https://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown Automaton</see> with states as objects.
             
             If your state classes have an empty constructor, the state machine can register the states automatically when needed (using <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateAuto``1"/> and <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeStateAuto``1"/>).
             If not you should register the states yourself using <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType``1"/> or <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})"/> and use the regular.
             
             The machine will automatically pool the states so you don't have to worry about it.
            
             Whether or popping the last state is valid is up to your design.
             
             <seealso cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/>
             <seealso cref="T:Archon.SwissArmyLib.Automata.PdaState`1"/>
             </summary>
             <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.Context">
            <summary>
            A shared context which all states have access to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.CurrentState">
            <summary>
            The active state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.#ctor(`0)">
            <summary>
            Creates a new PushdownAutomaton.
            
            You should use <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})"/> to register which state types that can be used with the machine.
            </summary>
            <param name="context">Data shared among states</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.Update(System.Single)">
            <summary>
            Call this every time the machine should update. Eg. every frame.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeState``1">
            <summary>
            Replaces the active state with another state, without notifying the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The state instance that was changed to.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeStateAuto``1">
            <summary>
            Replaces the active state with another state, without notifying the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeState``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The state instance that was changed to.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopState">
            <summary>
            Pops the current state and resumes the underlying state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopStateSilently">
            <summary>
            Pops the current state without notifying the underlying state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopAll(System.Boolean)">
            <summary>
            Pops all states in the stack.
            </summary>
            <param name="excludingRoot">Whether to keep the bottom state.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushState``1">
            <summary>
            Pushes a state to the top of the stack and pauses the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilently``1">
            <summary>
            Pushes a state to the top of the stack without notifying the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateAuto``1">
            <summary>
            Pushes a state to the top of the stack and pauses the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushState``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilentlyAuto``1">
            <summary>
            Pushes a state to the top of the stack without notifying the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilently``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ObtainState``1">
            <summary>
            Obtains a pooled instance of the given type.
            </summary>
            <typeparam name="TState">The type of the state to obtain.</typeparam>
            <returns>The new or recycled state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.FreeState(Archon.SwissArmyLib.Automata.IPdaState{`0})">
            <summary>
            Frees a state instance and makes it available for reuse.
            </summary>
            <param name="state">The state to free.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.GetPool(System.Type)">
            <summary>
            Gets a pool for the given state type.
            </summary>
            <param name="stateType">The state type to get the pool for.</param>
            <returns>The pool, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType``1">
            <summary>
            Registers a state type in the machine. 
            
            A pool for the type will be created that will use the empty constructor.
            </summary>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})">
            <summary>
            Registers a state type in the machine. 
            
            A pool for the type will be created which uses the given creationMethod to create new instance when needed.
            </summary>
            <param name="type">The state type to register.</param>
            <param name="creationMethod">The factory method to use for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.IsRegistered``1">
            <summary>
            Checks whether a state type is registered in the machine.
            </summary>
            <typeparam name="TState">The state type to check for.</typeparam>
            <returns>True if registered, otherwise false.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.IFsmState`1">
            <summary>
            Represents a state to be used in a <see cref="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1"/>.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.FsmState`1">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/> and can be used in a <see cref="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1"/>
            
            You're not required to use this, but it's easier.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1">
             <summary>
             A simple <see href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite State Machine</see> with states as objects inspired by Prime31's excellent <see href="https://github.com/prime31/StateKit">StateKit</see>.
            
             If your state classes have an empty constructor, the state machine can create the states automatically when needed (using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/>).
             If not you should create the state instance yourself and register the state in the machine.
            
             Whether or not a null state is valid is up to your design.
             
             <seealso cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/>
             <seealso cref="T:Archon.SwissArmyLib.Automata.FsmState`1"/>
             </summary>
             <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.Context">
            <summary>
            A shared context which all states have access to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.CurrentState">
            <summary>
            The active state.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.PreviousState">
            <summary>
            The previously active state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.#ctor(`0)">
            <summary>
            Creates a new Finite State Machine.
            
            If you need control over how the states are created, you can register them manually using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})"/>.
            If not, then you can freely use <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/> which will create the states using their default constructor.
            </summary>
            <param name="context">A shared context for the states.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.#ctor(`0,Archon.SwissArmyLib.Automata.IFsmState{`0})">
            <summary>
            Creates a new Finite State Machine and changes the state to <paramref name="startState"/>.
            
            If you need control over how the states are created, you can register them manually using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})"/>.
            If not, then you can freely use <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/> which will create the states using their default constructor.
            </summary>
            <param name="context"></param>
            <param name="startState"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.Update(System.Single)">
            <summary>
            Call this every time the machine should update. Eg. every frame.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})">
            <summary>
            Preemptively add a state instance.
            Useful if the state doesn't have an empty constructor and therefore cannot be used with ChangeStateAuto.
            </summary>
            <param name="state">The state to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered(System.Type)">
            <summary>
            Checks whether a state type is registered.
            </summary>
            <param name="stateType">The state type to check.</param>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered``1">
            <summary>
            Generic version of <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered(System.Type)"/>.
            Checks whether a state type is registered.
            </summary>
            <typeparam name="TState">The state type to check.</typeparam>
            <returns>Tru if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1">
            <summary>
            Changes the active state to the given state type.
            If a state of that type isn't already registered, it will automatically create a new instance using the empty constructor.
            </summary>
            <typeparam name="TState"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeState``1">
            <summary>
            Changes the active state to the given state type. 
            An instance of that type should already had been registered to use this method.
            </summary>
            <typeparam name="TState"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeState``1(``0)">
            <summary>
            Changes the active state to a specific state instance.
            This will (if not null) also register the state.
            </summary>
            <typeparam name="TState"></typeparam>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.BaseState`2">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IState`2"/>.
            
            You might be looking for <see cref="T:Archon.SwissArmyLib.Automata.FsmState`1"/> or <see cref="T:Archon.SwissArmyLib.Automata.PdaState`1"/>.
            </summary>
            <typeparam name="TMachine">The type of the machine.</typeparam>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.Machine">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.Context">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.TimeInState">
            <summary>
            Amount of (active) time spent in this state since it was entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Begin">
            <summary>
            Called when the state is entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Reason">
            <summary>
            Called every frame just before <see cref="M:Archon.SwissArmyLib.Automata.BaseState`2.Act(System.Single)"/>. 
            Use this to check whether you should change state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Act(System.Single)">
            <summary>
            Called every frame after <see cref="M:Archon.SwissArmyLib.Automata.BaseState`2.Reason"/>, if the state hasn't been changed.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.End">
            <summary>
            Called when the state is exited.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.DelayedList`1">
            <summary>
                A list wrapper that delays adding or removing item from the list until <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <typeparam name="T">The type of items this list should contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.Count">
            <summary>
                Gets the amount of items in the list.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor">
            <summary>
                Creates a new DelayedList which uses <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor(System.Int32,System.Int32)">
            <summary>
                Creates a new DelayedList which uses <see cref="T:System.Collections.Generic.List`1" /> and has the specified initial capacity and change capacity.
            </summary>
            <param name="capacity">The initial capacity of the list.</param>
            <param name="changeCapacity">The initial capacity of the change queue.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
                Creates a new DelayedList that wraps the given list.
            </summary>
            <param name="list">The list to wrap.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
                Creates a new DelayedList that wraps the given list.
            </summary>
            <param name="list">The list to wrap.</param>
            <param name="changeCapacity">The initial capacity of the change queue.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.BackingList">
            <summary>
                A readonly version of the list containing processed items.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.Item(System.Int32)">
            <summary>
                Gets the item at a specific index.
            </summary>
            <param name="index">The index of the item.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.GetEnumerator">
            <summary>
                Gets an enumerator for the backing list.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets an enumerator for the backing list.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Add(`0)">
            <summary>
                Adds an item to the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Adds multiple items to the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="items">The items to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Remove(`0)">
            <summary>
                Removes an item from the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Clear">
            <summary>
                Clears all items from the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending"/> is called.
            
                <seealso cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ClearInstantly"/>
                <seealso cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ClearPending"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.ClearInstantly">
            <summary>
                Clears all items from the list and all pending additions and removals instantly, without having to call <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending"/>.
            
                <seealso cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.Clear"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.ClearPending">
            <summary>
                Clears all pending changes.
            
                <seealso cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.Clear"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Contains(`0)">
            <summary>
                Checks whether the backing list currently contains a specific item.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the contents of the backing list to the specified array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start from.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.IndexOf(`0)">
            <summary>
                Gets the index of an item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item, or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.RemoveAt(System.Int32)">
            <summary>
                Removes the value currently found at the specified index the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending">
            <summary>
                Processes all pending additions and removals.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2">
            <summary>
            A <see cref="T:System.Collections.Generic.Dictionary`2"/> but with a default value for missing entries.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.DefaultValue">
            <summary>
            Default value for missing entries.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the given key.
            
            If the key isn't in the dictionary, <see cref="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.DefaultValue"/> will be returned.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor">
            <summary>
            Creates a new Dictionary with DefaultValue set to TValue's default value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor(`1)">
            <summary>
            Creates a new Dictionary using the supplied value as the default for missing entries.
            </summary>
            <param name="defaultValue"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor(`1,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Dictionary using the supplied value as the default for missing entries and a specific comparer.
            </summary>
            <param name="defaultValue"></param>
            <param name="comparer"></param>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.Grid3D`1">
            <summary>
            A generic three-dimensional grid.
            
            <seealso cref="T:Archon.SwissArmyLib.Collections.Grid2D`1"/>
            </summary>
            <typeparam name="T">The type of content cells can contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Width">
            <summary>
            Gets the width (number of columns) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Height">
            <summary>
            Gets the height (number of rows) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Depth">
            <summary>
            Gets the depth (number of layers) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue">
            <summary>
            Gets or sets the default values used for clearing or initializing new cells.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets or sets the value of the cell located at the specified coordinate.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>The contents of the cell.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new 3D Grid with the specified width, height and depth. 
            Cells will be initialized with their type's default value.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="depth">Number of layers</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.#ctor(System.Int32,System.Int32,System.Int32,`0)">
            <summary>
            Creates a new 3D Grid with the specified width, height and depth. 
            Cells will be initialized with the value of <paramref name="defaultValue"/>.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="depth">Number of layers</param>
            <param name="defaultValue">The value used for initializing new cells.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Get(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>The cell contents.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Set(System.Int32,System.Int32,System.Int32,`0)">
            <summary>
            Sets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="value">The value to set the cell to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Clear">
            <summary>
            Clears the grid, setting every cell to <see cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Clear(`0)">
            <summary>
            Clears the grid, setting every cell to the given value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Fill(`0,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills everything in the specified cube to the given value.
            </summary>
            <param name="value">The value to fill the cells with.</param>
            <param name="minX">Bottom left front corner's x value.</param>
            <param name="minY">Bottom left front corner's y value.</param>
            <param name="minZ">Bottom left front corner's z value.</param>
            <param name="maxX">Upper right back corner's x value.</param>
            <param name="maxY">Upper right back corner's y value.</param>
            <param name="maxZ">Upper right back corner's z value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Resize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes the Grid to the given size, keeping data the same but any new cells will be set to <see cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue"/>.
            
            Growing the grid will allocate new arrays, shrinking will not.
            </summary>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
            <param name="depth">The new depth.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.PooledLinkedList`1">
            <summary>
                A wrapper for <see cref="T:System.Collections.Generic.LinkedList`1" /> that recycles its <see cref="T:System.Collections.Generic.LinkedListNode`1" /> instances to reduce
                GC allocations.
            </summary>
            <typeparam name="T">Type of items the list should contain.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.#ctor">
            <summary>
                Initializes a new empty PooledLinkedList&lt;T&gt; with its own node pool.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.#ctor(Archon.SwissArmyLib.Pooling.IPool{System.Collections.Generic.LinkedListNode{`0}})">
            <summary>
                Initializes a new empty PooledLinkedList&lt;T&gt; that uses a specified node pool.
            </summary>
            <param name="nodePool">The pool that should be used spawning/despawning new nodes.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Initializes a new PooledLinkedList&lt;T&gt; with its own node pool and the contents of the specified
                <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
            <param name="collection">A collection of items to fill with PooledLinkedList&lt;T&gt; with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0},Archon.SwissArmyLib.Pooling.IPool{System.Collections.Generic.LinkedListNode{`0}})">
            <summary>
                Initializes a new PooledLinkedList&lt;T&gt; with a custom node pool and the contents of the specified
                <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
            <param name="collection">A collection of items to fill with PooledLinkedList&lt;T&gt; with.</param>
            <param name="nodePool">The pool that should be used spawning/despawning new nodes.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PooledLinkedList`1.BackingList">
            <summary>
                Gets the <see cref="T:System.Collections.Generic.LinkedList`1" /> instance that is wrapped.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Pool">
            <summary>
                Gets the object pool used for storing unused nodes.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PooledLinkedList`1.First">
            <summary>
                Gets the first node of the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Last">
            <summary>
                Gets the last node of the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Count">
            <summary>
                Gets the number of nodes contained in the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Clear">
            <summary>
                Removes all nodes from the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Contains(`0)">
            <summary>
                Determines whether a value is in the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if the list contains the item, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the entire PooledLinkedList&lt;T&gt; to a compatible one-dimensional Array, starting at the specified index
                of the target array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start at.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Remove(`0)">
            <summary>
                Removes the first occurrence of the specified value from the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if found and removed, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the PooledLinkedList&lt;T&gt;.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
                Adds a new node containing the specified value after the specified existing node in the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node that <paramref name="value" /> should be added after.</param>
            <param name="value">The value to add.</param>
            <returns>The added node.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})">
            <summary>
                Adds the specified new node after the specified existing node in the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node that <paramref name="newNode" /> should be added after.</param>
            <param name="newNode">The node to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>
                Adds a new node containing the specified value before the specified existing node in the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node that <paramref name="value" /> should be added before.</param>
            <param name="value">The value to add.</param>
            <returns>The added node.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})">
            <summary>
                Adds the specified new node before the specified existing node in the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node that <paramref name="newNode" /> should be added before.</param>
            <param name="newNode">The node to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddFirst(`0)">
            <summary>
                Adds a new node containing the specified value at the start of the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="value">The value to add.</param>
            <returns>The node that was added.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddFirst(System.Collections.Generic.LinkedListNode{`0})">
            <summary>
                Adds the specified new node at the start of the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddLast(`0)">
            <summary>
                Adds a new node containing the specified value at the end of the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="value">The value to add.</param>
            <returns>The node that was added.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.AddLast(System.Collections.Generic.LinkedListNode{`0})">
            <summary>
                Adds the specified new node at the end of the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Find(`0)">
            <summary>
                Finds the first node that contains the specified value.
            </summary>
            <param name="value">The value to search for.</param>
            <returns>The found node or null if none were found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.FindLast(`0)">
            <summary>
                Finds the last node that contains the specified value.
            </summary>
            <param name="value">The value to search for.</param>
            <returns>The found node or null if none were found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})">
            <summary>
                Removes the specified node from the PooledLinkedList&lt;T&gt;.
            </summary>
            <param name="node">The node to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.RemoveFirst">
            <summary>
                Removes the node at the start of the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PooledLinkedList`1.RemoveLast">
            <summary>
                Removes the node at the end of the PooledLinkedList&lt;T&gt;.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.PrioritizedItem`1">
            <summary>
            Represents an item and its priority.
            </summary>
            <typeparam name="T">The type of the item.</typeparam>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Item">
            <summary>
            The item that is prioritized.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Priority">
            <summary>
            The priority of the item.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedItem`1.#ctor(`0,System.Int32)">
            <summary>
            Creates a new prioritized item.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Equals(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedItem`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.ListSortDirection">
            <summary>
            Specifies the direction of a sort operation.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.ListSortDirection.Ascending">
            <summary>
            Sorts in ascending order.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.ListSortDirection.Descending">
            <summary>
            Sorts in descending order.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.PrioritizedList`1">
            <summary>
            A list of items sorted by their priority.
            </summary>
            <typeparam name="T">The type of the prioritized items.</typeparam>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.PrioritizedList`1.SortDirection">
            <summary>
            Gets the sorting direction used for prioritized items in this list.
            
            <b>Ascending</b>: Lower priorities are placed first.
            <b>Descending</b>: Lower priorities are placed last.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PrioritizedList`1.Count">
            <summary>
            Gets the amount of items in the list.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PrioritizedList`1.Item(System.Int32)">
            <summary>
            Gets the item at the specified index.
            </summary>
            <param name="index">The index for the item to retrieve.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.#ctor(Archon.SwissArmyLib.Collections.ListSortDirection)">
            <summary>
            Creates a new PrioritizedList with the specified sort direction.
            </summary>
            <param name="sortDirection">Whether items with lower priorities are placed first in the list (ascending) or last (descending).</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.#ctor(System.Int32,Archon.SwissArmyLib.Collections.ListSortDirection)">
            <summary>
            Creates a new PrioritizedList with the specified sort direction and initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
            <param name="sortDirection">Whether items with lower priorities are placed first in the list (ascending) or last (descending).</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Adds a prioritized item to the list.
            </summary>
            <param name="item">The prioritized item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(`0)">
            <summary>
            Adds an item to the list with priority 0.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(`0,System.Int32)">
            <summary>
            Adds an item to the list with the specified priority.
            </summary>
            <param name="item">The item to add.</param>
            <param name="priority">The priority to give the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Remove(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Removes a prioritized item from the list.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if found and removed, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Remove(`0)">
            <summary>
            Removes an item from the list.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if found and removed, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item found at the specified index.
            </summary>
            <param name="index">The index of the item to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Clear">
            <summary>
            Clears all items from the list.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Contains(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Checks whether the list contains the specified prioritized item.
            </summary>
            <param name="item">The item to check if the list contains.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Contains(`0)">
            <summary>
            Checks whether the list contains the specified item.
            </summary>
            <param name="item">The item to check if the list contains.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.CopyTo(Archon.SwissArmyLib.Collections.PrioritizedItem{`0}[],System.Int32)">
            <summary>
            Copies the list prioritized items to an array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start at.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the list items to an array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start at.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.IndexOf(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Gets the index of a prioritized item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item in the list or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.IndexOf(`0)">
            <summary>
            Gets the index of a item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item in the list or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.GetEnumerator">
            <summary>
            Gets an enumerator for the list items.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.Grid2D`1">
            <summary>
            A generic two-dimensional grid.
            
            <seealso cref="T:Archon.SwissArmyLib.Collections.Grid3D`1"/>
            </summary>
            <typeparam name="T">The type of content cells can contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Width">
            <summary>
            Gets the width (number of columns) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Height">
            <summary>
            Gets the height (number of rows) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue">
            <summary>
            Gets or sets the default values used for clearing or initializing new cells.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value of the cell located at the specified coordinate.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The contents of the cell.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 2D Grid with the specified width and height. 
            Cells will be initialized with their type's default value.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Creates a new 2D Grid with the specified width and height. 
            Cells will be initialized with the value of <paramref name="defaultValue"/>.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="defaultValue">The value used for initializing new cells.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Get(System.Int32,System.Int32)">
            <summary>
            Gets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The cell contents.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Sets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="value">The value to set the cell to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Clear">
            <summary>
            Clears the grid, setting every cell to <see cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Clear(`0)">
            <summary>
            Clears the grid, setting every cell to the given value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Fill(`0,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills everything in the specified rectangle to the given value.
            </summary>
            <param name="value">The value to fill the cells with.</param>
            <param name="minX">Bottom left corner's x value.</param>
            <param name="minY">Bottom left corner's y value.</param>
            <param name="maxX">Upper right corner's x value.</param>
            <param name="maxY">Upper right corner's y value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Resize(System.Int32,System.Int32)">
            <summary>
            Resizes the Grid to the given size, keeping data the same but any new cells will be set to <see cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue"/>.
            
            Growing the grid will allocate new arrays, shrinking will not.
            </summary>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Coroutines.BetterCoroutines">
            <summary>
            A very similar but more performant alternative to Unity's coroutines.
            
            A coroutine do not belong to any gameobject and therefore doesn't depend on their life cycle. 
            You can however optionally link the coroutines to a gameobject or component.
            
            Which update loop they're part of can be specified when they're started.
            
            They also allocate less garbage (especially with the yield instructions).
            
            Just as with Unity's coroutines you can yield a <see cref="T:UnityEngine.WWW"/> and <see cref="T:UnityEngine.AsyncOperation"/> to wait for them to finish.
            
            Instead of using Unity's YieldInstructions you should use the pooled replacements:
            <list type="bullet">
                <item><description><see cref="F:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForOneFrame"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForSeconds(System.Single,System.Boolean)"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForSecondsRealtime(System.Single)"/></description></item>
                <item><description><see cref="F:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForEndOfFrame"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitUntil(System.Func{System.Boolean})"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitWhile(System.Func{System.Boolean})"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForWWW(UnityEngine.WWW)"/></description></item>
                <item><description><see cref="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForAsyncOperation(UnityEngine.AsyncOperation)"/></description></item>
            </list>
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForOneFrame">
            <summary>
            Suspends a coroutine for one frame.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForEndOfFrame">
            <summary>
            Suspends a coroutine until the very end of the current frame.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine.
            </summary>
            <param name="enumerator"></param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,System.Int32)">
            <summary>
            Starts a new coroutine.
            </summary>
            <param name="enumerator"></param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,UnityEngine.GameObject,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine and links its lifetime to a gameobject.
            The coroutine will be stopped when the linked gameobject is disabled or destroyed.
            </summary>
            <param name="enumerator"></param>
            <param name="linkedObject">Which gameobject to link the coroutine's lifetime with.</param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,UnityEngine.GameObject,System.Int32)">
            <summary>
            Starts a new coroutine and links its lifetime to a gameobject.
            The coroutine will be stopped when the linked gameobject is disabled or destroyed.
            </summary>
            <param name="enumerator"></param>
            <param name="linkedObject">Which gameobject to link the coroutine's lifetime with.</param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,UnityEngine.MonoBehaviour,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine and links its lifetime to a component.
            The coroutine will be stopped when the linked component is disabled or destroyed.
            </summary>
            <param name="enumerator"></param>
            <param name="linkedComponent">Which component to link the coroutine's lifetime with.</param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Start(System.Collections.IEnumerator,UnityEngine.MonoBehaviour,System.Int32)">
            <summary>
            Starts a new coroutine and links its lifetime to a component.
            The coroutine will be stopped when the linked component is disabled or destroyed.
            </summary>
            <param name="enumerator"></param>
            <param name="linkedComponent">Which component to link the coroutine's lifetime with.</param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.IsRunning(System.Int32)">
            <summary>
            Checks whether a coroutine with the given ID is running.
            
            A paused coroutine is still considered running.
            </summary>
            <param name="id">The id of the coroutine to check.</param>
            <returns>True if running, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.SetPaused(System.Int32,System.Boolean)">
            <summary>
            Pauses or unpauses a coroutine.
            </summary>
            <param name="id">The id of the coroutine.</param>
            <param name="paused">True to pause, false to unpause.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.IsPaused(System.Int32)">
            <summary>
            Checks whether a coroutine is currently paused either directly or because of a paused parent.
            </summary>
            <param name="id">Id of the coroutine.</param>
            <returns>True if paused or parent is paused, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Pause(System.Int32)">
            <summary>
            Pauses a coroutine.
            </summary>
            <param name="id">Id of the coroutine to pause.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Unpause(System.Int32)">
            <summary>
            Unpauses a paused coroutine.
            </summary>
            <param name="id">Id of the coroutine to unpause.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.Stop(System.Int32)">
            <summary>
            Stops a running coroutine prematurely. 
            
            This will stop any child coroutines as well.
            </summary>
            <param name="id">The id of the coroutine to stop.</param>
            <returns>True if the coroutine was found and stopped, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.StopAll">
            <summary>
            Stops all coroutines.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.StopAll(Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Stops all coroutines that are running in the specified update loop.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.StopAll(System.Int32)">
            <summary>
            Stops all coroutines that are running in the specified update loop.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForSeconds(System.Single,System.Boolean)">
            <summary>
            Waits for the specified amount of seconds, either in scaled time (just as Unity's <see cref="T:UnityEngine.WaitForSeconds"/>) or in unscaled time.
            </summary>
            <param name="seconds">Duration in seconds to wait before continuing.</param>
            <param name="unscaled">Should the wait time ignore <see cref="P:UnityEngine.Time.timeScale"/>?</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForSecondsRealtime(System.Single)">
            <summary>
            Waits for the specified amount of seconds in real time.
            
            Lighter replacement for <see cref="T:UnityEngine.WaitForSecondsRealtime"/>.
            </summary>
            <param name="seconds">The amount of seconds to wait for.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForAsyncOperation(UnityEngine.AsyncOperation)">
            <summary>
            Waits until the specified <see cref="T:UnityEngine.AsyncOperation"/> is done.
            </summary>
            <param name="operation">The async operation to wait for.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitForWWW(UnityEngine.WWW)">
            <summary>
            Waits until the specified <see cref="T:UnityEngine.WWW"/> object has finished.
            </summary>
            <param name="www">The WWW object to wait for.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitUntil(System.Func{System.Boolean})">
            <summary>
            Waits until the given predicate returns true.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutines.WaitWhile(System.Func{System.Boolean})">
            <summary>
            Waits until the given predicate returns false.
            </summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions">
            <summary>
            A bunch of helpful extensions for starting and stopping coroutines.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutine(UnityEngine.Object,System.Collections.IEnumerator,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine.
            </summary>
            <param name="unityObject"></param>
            <param name="enumerator"></param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutine(UnityEngine.Object,System.Collections.IEnumerator,System.Int32)">
            <summary>
            Starts a new coroutine.
            </summary>
            <param name="unityObject"></param>
            <param name="enumerator"></param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutineLinked(UnityEngine.MonoBehaviour,System.Collections.IEnumerator,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine with its lifetime linked to this component.
            The coroutine will be stopped when the linked component is disabled or destroyed.
            </summary>
            <param name="monoBehaviour">The component to link the coroutine to.</param>
            <param name="enumerator"></param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutineLinked(UnityEngine.MonoBehaviour,System.Collections.IEnumerator,System.Int32)">
            <summary>
            Starts a new coroutine with its lifetime linked to this component.
            The coroutine will be stopped when the linked component is disabled or destroyed.
            </summary>
            <param name="monoBehaviour">The component to link the coroutine to.</param>
            <param name="enumerator"></param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutineLinked(UnityEngine.GameObject,System.Collections.IEnumerator,Archon.SwissArmyLib.Utils.UpdateLoop)">
            <summary>
            Starts a new coroutine with its lifetime linked to this gameobject.
            The coroutine will be stopped when the linked gameobject is disabled or destroyed.
            </summary>
            <param name="gameObject">The gameobject to link the coroutine to.</param>
            <param name="enumerator"></param>
            <param name="updateLoop">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StartBetterCoroutineLinked(UnityEngine.GameObject,System.Collections.IEnumerator,System.Int32)">
            <summary>
            Starts a new coroutine with its lifetime linked to this gameobject.
            The coroutine will be stopped when the linked gameobject is disabled or destroyed.
            </summary>
            <param name="gameObject">The gameobject to link the coroutine to.</param>
            <param name="enumerator"></param>
            <param name="updateLoopId">Which update loop should the coroutine be part of?</param>
            <returns>The id of the coroutine.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.BetterCoroutinesExtensions.StopBetterCoroutine(UnityEngine.Object,System.Int32)">
            <summary>
            Stops a running coroutine prematurely. 
            
            This will stop any child coroutines as well.
            </summary>
            <param name="unityObject"></param>
            <param name="coroutineId">The id of the coroutine to stop.</param>
            <returns>True if the coroutine was found and stopped, otherwise false.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Coroutines.IPoolableYieldInstruction">
            <summary>
            Represents a yield instruction that can be freed when the coroutine they're running in is despawned.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Coroutines.IPoolableYieldInstruction.Despawn">
            <summary>
            Frees the yield instruction placing them back in its pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Coroutines.WaitForAsyncOperation.keepWaiting">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Coroutines.WaitForSecondsRealtimeLite.keepWaiting">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Coroutines.WaitForWWW.keepWaiting">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Coroutines.WaitUntilLite.keepWaiting">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Coroutines.WaitWhileLite.keepWaiting">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop">
            <summary>
            Represents an implementation of a custom update loop.
            
            You will probably be better of subclassing <see cref="T:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase"/> for
            a simpler start, but it's here if you need it.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop.Event">
            <summary>
            Gets the event associated with this update loop.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop.IsTimeToRun">
            <summary>
            Gets whether it's time for this update loop to run again.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop.DeltaTime">
            <summary>
            Gets the scaled time since this update loop last ran.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop.UnscaledDeltaTime">
            <summary>
            Gets the unscaled time since this update loop last ran.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop.Invoke">
            <summary>
            Runs this update loop's event.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase">
            <summary>
            An abstract class for custom update loops that implement basic 
            functionality to track invokation times and deltatimes.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.PreviousRunTimeScaled">
            <summary>
            Gets or sets in scaled time when this update loop last ran.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.PreviousRunTimeUnscaled">
            <summary>
            Gets or sets in unscaled time when this update loop last ran.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.Event">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.IsTimeToRun">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.DeltaTime">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.UnscaledDeltaTime">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.CustomUpdateLoopBase.Invoke">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop">
            <summary>
            A basic custom update loop that runs every nth frame.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop"/>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop.IsTimeToRun">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop.Interval">
            <summary>
            Gets or sets the frame interval that this update loop should run.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new FrameIntervalUpdateLoop.
            </summary>
            <param name="eventId">The event id that this update loop should use.</param>
            <param name="interval">The amount of frames between each call of this update loop.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop.Invoke">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdate">
            <summary>
            A relay for Unity update events.
            Here's why you might want to use this:
            https://blogs.unity3d.com/2015/12/23/1k-update-calls/
            In short; avoid overhead of Native C++ --> Managed C# calls.
            
            Also useful for non-MonoBehaviours that needs to be part of the update loop as well.
            
            Built-in events your can subscribe to:
            <list type="bullet">
                <item><description><see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/></description></item>
                <item><description><see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate"/></description></item>
                <item><description><see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate"/></description></item>
            </list>
            
            You can also create your own custom update loops (eg. to run every nth second) using 
            <see cref="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.AddCustomUpdateLoop(Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop,Archon.SwissArmyLib.Utils.UpdateLoop,System.Int32)"/> and <see cref="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.AddListener(System.Int32,System.Action,System.Int32)"/>.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour"/>
            <seealso cref="T:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop"/>
            <seealso cref="T:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop"/>
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate">
            <summary>
            Event handler that is called every update.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate">
            <summary>
            Event handler that is called every update but after the regular Update.
            <seealso cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/>
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate">
            <summary>
            Event handler that is called every fixed update.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.DeltaTime">
            <summary>
            Gets the difference in seconds since the previous update of the currently running type. (Scaled according to <see cref="P:UnityEngine.Time.timeScale"/>)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.UnscaledDeltaTime">
            <summary>
            Gets the unscaled difference in seconds since the previous update of the currently running type.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.EventIds">
            <summary>
            Relayed event ids.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.AddCustomUpdateLoop(Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop,Archon.SwissArmyLib.Utils.UpdateLoop,System.Int32)">
            <summary>
            Adds a custom update loop.
            </summary>
            <param name="updateLoop">The custom update loop implementation.</param>
            <param name="parentLoop">Which Unity update loop should this be run under?</param>
            <param name="priority">A priority that decides whether this update loop runs before or after other custom update loops.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.RemoveCustomUpdateLoop(Archon.SwissArmyLib.Events.Loops.ICustomUpdateLoop)">
            <summary>
            Removes a custom update loop.
            </summary>
            <param name="updateLoop">The update loop to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.RemoveCustomUpdateLoop(System.Int32)">
            <summary>
            Removes a custom update loop with the given event id.
            </summary>
            <param name="eventId">The event id that the custom update loop uses.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.GetCustomUpdateLoop``1(System.Int32)">
            <summary>
            Gets the custom update loop implementation for the given event id.
            </summary>
            <typeparam name="T">The type of the update loop.</typeparam>
            <param name="eventId">The event id that the update loop uses.</param>
            <returns>The custom update loop or null if not found or wrong type.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.GetCustomUpdateLoop(System.Int32)">
            <summary>
            Gets the custom update loop implementation for the given event id.
            </summary>
            <param name="eventId">The event id for the update loop.</param>
            <returns>The custom update loop or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.AddListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener,System.Int32)">
            <summary>
            Adds a listener for an update loop.
            
            If it's not a custom update loop, you can instead subscribe directly using 
            <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/>, <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate"/> or <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate"/>.
            </summary>
            <param name="eventId">The event id of the update loop to subscribe to.</param>
            <param name="listener">The listener to add to the update loop.</param>
            <param name="priority">The priority of the listener, controlling whether the listener 
            is called before (lower) or later (higher) than other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.AddListener(System.Int32,System.Action,System.Int32)">
            <summary>
            Adds a listener for an update loop.
            
            If it's not a custom update loop, you can instead subscribe directly using 
            <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/>, <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate"/> or <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate"/>.
            </summary>
            <param name="eventId">The event id of the update loop to subscribe to.</param>
            <param name="listener">The listener to add to the update loop.</param>
            <param name="priority">The priority of the listener, controlling whether the listener 
            is called before (lower) or later (higher) than other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.RemoveListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes a listener for an update loop.
            
            If it's not a custom update loop, you can instead unsubscribe directly using 
            <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/>, <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate"/> or <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate"/>.
            </summary>
            <param name="eventId">The event id of the update loop to unsubscribe from.</param>
            <param name="listener">The listener to remove from the update loop.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.RemoveListener(System.Int32,System.Action)">
            <summary>
            Removes a listener for an update loop.
            
            If it's not a custom update loop, you can instead unsubscribe directly using 
            <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnUpdate"/>, <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnLateUpdate"/> or <see cref="F:Archon.SwissArmyLib.Events.Loops.ManagedUpdate.OnFixedUpdate"/>.
            </summary>
            <param name="eventId">The event id of the update loop to unsubscribe from.</param>
            <param name="listener">The listener to remove from the update loop.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.IUpdateable">
            <summary>
            Makes a <see cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour"/> subclass get notified on an update.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.IUpdateable.OnUpdate">
            <summary>
            Called every frame.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ILateUpdateable">
            <summary>
            Makes a <see cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour"/> subclass get notified on a late update.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ILateUpdateable.OnLateUpdate">
            <summary>
            Called every frame, after the regular update loop.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.IFixedUpdateable">
            <summary>
            Makes a <see cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour"/> subclass get notified on a fixed update.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.IFixedUpdateable.OnFixedUpdate">
            <summary>
            Called every fixed update.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ICustomUpdateable">
            <summary>
            Makes a <see cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour"/> subclass get notified when a custom update loop ticks.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ICustomUpdateable.GetCustomUpdateIds">
            <summary>
            Gets the event ids for the custom update loops that should be listened to.
            </summary>
            <returns>The event ids to listen for.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ICustomUpdateable.OnCustomUpdate(System.Int32)">
            <summary>
            Called whenever one of the custom update loops tick.
            </summary>
            <param name="eventId"></param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour">
            <summary>
            A subclass of MonoBehaviour that uses <see cref="T:Archon.SwissArmyLib.Events.Loops.ManagedUpdate"/> for update events.
            
            To receive updates implement one or more of the appropriate interfaces: 
            <see cref="T:Archon.SwissArmyLib.Events.Loops.IUpdateable"/>, <see cref="T:Archon.SwissArmyLib.Events.Loops.ILateUpdateable"/>, <see cref="T:Archon.SwissArmyLib.Events.Loops.IFixedUpdateable"/> and <see cref="T:Archon.SwissArmyLib.Events.Loops.ICustomUpdateable"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour.ExecutionOrder">
            <summary>
            Affects whether this components' events will be called before or after others'.
            
            Basically a reimplementation of Unity's ScriptExecutionOrder.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour.Start">
            <summary>
            Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour.OnEnable">
            <summary>
            Called when the component is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour.OnDisable">
            <summary>
            Called when the component is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.ManagedUpdateBehaviour.OnEvent(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop">
            <summary>
            A basic custom update loop that runs every nth second either in scaled or unscaled time.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.Loops.FrameIntervalUpdateLoop"/>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop.IsTimeToRun">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop.Interval">
            <summary>
            Gets or sets the amount of seconds between each time this update loop runs.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop.UsingScaledTime">
            <summary>
            Gets whether this interval update loop uses scaled or unscaled time for its interval.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop.#ctor(System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates a new TimeIntervalUpdateLoop.
            </summary>
            <param name="eventId">The event id that the update loop should use.</param>
            <param name="interval">The amount of seconds between each time this update loop should run.</param>
            <param name="usingScaledTime">Whether the interval should use scaled or unscaled time.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Loops.TimeIntervalUpdateLoop.Invoke">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.BuiltinEventIds">
            <summary>
                Contains the event ids used by SwissArmyLib.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.Update">
            <summary>
                ManagedUpdate
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.LateUpdate">
            <summary>
                ManagedUpdate
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.FixedUpdate">
            <summary>
                ManagedUpdate
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.PreChange">
            <summary>
                ResourcePool
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.Change">
            <summary>
                ResourcePool
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.Empty">
            <summary>
                ResourcePool
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.Full">
            <summary>
                ResourcePool
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.BuiltinEventIds.Renew">
            <summary>
                ResourcePool
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event">
            <summary>
            A simple event handler that supports using both interface and delegate listeners.
            
            This is the parameterless version. 
            See <see cref="T:Archon.SwissArmyLib.Events.Event`1"/> if you need to send data with the event.
            
            Interface listeners are required to implement the <see cref="T:Archon.SwissArmyLib.Events.IEventListener"/> interface.
            
            Events are differentiated by an integer. You are expected to create constants to define your events and make them unique.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event.Id">
            <summary>
            Gets the ID of this event.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event.SuppressExceptions">
            <summary>
            Gets or sets whether listener exceptions should be logged. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event.Listeners">
            <summary>
            Gets a readonly collection of current listeners.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.#ctor(System.Int32)">
            <summary>
            Creates a new Event with the specified ID.
            </summary>
            <param name="id">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Event with the specified ID and initial listener capacity.
            </summary>
            <param name="id">The id of the event.</param>
            <param name="initialListenerCapacity">The initial capacity for listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.AddListener(Archon.SwissArmyLib.Events.IEventListener,System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.AddListener(System.Action,System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.RemoveListener(Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.RemoveListener(System.Action)">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.HasListener(Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Checks whether the specified listener is currently listening to this event.
            </summary>
            <param name="listener">The listener to check.</param>
            <returns>True if listening, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.HasListener(System.Action)">
            <summary>
            Checks whether the specified listener is currently listening to this event.
            </summary>
            <param name="listener">The listener to check.</param>
            <returns>True if listening, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Invoke">
            <summary>
            Notifies all listeners that the event occured.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Clear">
            <summary>
            Clears all listeners
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event.Listener">
            <summary>
            Represents either a delegate or interface listener.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Event.Listener.DelegateListener">
            <summary>
            Gets this listener's delegate reference.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Event.Listener.InterfaceListener">
            <summary>
            Gets this listener's interface reference.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Listener.Equals(Archon.SwissArmyLib.Events.Event.Listener)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Listener.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Listener.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event`1">
            <summary>
            A simple event handler that supports using both interface and delegate listeners.
            
            This is the parameterized version. 
            See <see cref="T:Archon.SwissArmyLib.Events.Event"/> if you don't need to send data with the event.
            
            Interface listeners are required to implement the <see cref="T:Archon.SwissArmyLib.Events.IEventListener`1"/> interface.
            
            Events are differentiated by an integer. You are expected to create constants to define your events and make them unique.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event`1.Id">
            <summary>
            Gets the ID of this event.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event`1.SuppressExceptions">
            <summary>
            Gets or sets whether listener exceptions should be logged. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event`1.Listeners">
            <summary>
            Gets a readonly collection of current listeners.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.#ctor(System.Int32)">
            <summary>
            Creates a new Event with the specified ID.
            </summary>
            <param name="id">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Event with the specified ID and initial listener capacity.
            </summary>
            <param name="id">The id of the event.</param>
            <param name="initialListenerCapacity">The initial capacity for listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.AddListener(Archon.SwissArmyLib.Events.IEventListener{`0},System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.AddListener(System.Action{`0},System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.RemoveListener(Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.RemoveListener(System.Action{`0})">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.HasListener(Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Checks whether the specified listener is currently listening to this event.
            </summary>
            <param name="listener">The listener to check.</param>
            <returns>True if listening, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.HasListener(System.Action{`0})">
            <summary>
            Checks whether the specified listener is currently listening to this event.
            </summary>
            <param name="listener">The listener to check.</param>
            <returns>True if listening, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Invoke(`0)">
            <summary>
            Notifies all listeners that the event occured.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Clear">
            <summary>
            Clears all listeners
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event`1.Listener">
            <summary>
            Represents either a delegate or interface listener.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Event`1.Listener.DelegateListener">
            <summary>
            Gets this listener's delegate reference.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.Event`1.Listener.InterfaceListener">
            <summary>
            Gets this listener's interface reference.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Listener.Equals(Archon.SwissArmyLib.Events.Event{`0}.Listener)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Listener.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Listener.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Events.GlobalEvents">
            <summary>
            A manager of events that do not belong to any specific object but instead can be listened to by anyone and invoked by anyone.
            
            Useful for GameLoaded, MatchEnded and similar events.
            
            This uses <see cref="T:Archon.SwissArmyLib.Events.Event"/> instances behind the scenes.
            
            This version is for parameterless events. 
            See <see cref="T:Archon.SwissArmyLib.Events.GlobalEvents`1"/> if you need to send data with the events.
            
            Events are differentiated by an integer. You are expected to create constants to define your events.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.IEventListener"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Invoke(System.Int32)">
            <summary>
            Invokes an event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.AddListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener,System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.AddListener(System.Int32,System.Action,System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(System.Int32,System.Action)">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(System.Action)">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Clear">
            <summary>
            Clears all listeners for all events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Clear(System.Int32)">
            <summary>
            Clears all listeners for a single event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.GlobalEvents`1">
            <summary>
            A manager of events that do not belong to any specific object but instead can be listened to by anyone and invoked by anyone.
            
            Useful for GameLoaded, MatchEnded and similar events.
            
            This uses <see cref="T:Archon.SwissArmyLib.Events.Event`1"/> instances behind the scenes.
            
            This version is for events with args. 
            See <see cref="T:Archon.SwissArmyLib.Events.GlobalEvents"/> if you don't need to send data with the events.
            
            Events are differentiated by an integer. You are expected to create constants to define your events.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.IEventListener`1"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Invoke(System.Int32,`0)">
            <summary>
            Invokes an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="args">The event args.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.AddListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener{`0},System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.AddListener(System.Int32,System.Action{`0},System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(System.Int32,System.Action{`0})">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(System.Action{`0})">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Clear">
            <summary>
            Clears all listeners for all events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Clear(System.Int32)">
            <summary>
            Clears all listeners for a single event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.IEventListener">
            <summary>
            Defines a method to be used for event callbacks.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.IEventListener.OnEvent(System.Int32)">
            <summary>
            Called when an event is invoked.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.IEventListener`1">
            <summary>
            Defines a method to be used for event callbacks with a parameter of type <typeparamref name="TArgs"/>.
            </summary>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.IEventListener`1.OnEvent(System.Int32,`0)">
            <summary>
            Called when an event is invoked.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="args">The args for the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.TellMeWhen">
            <summary>
            A utility class for getting notified after a specific amount of time.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.TellMeWhen.NoId">
            <summary>
            Default id, if none is supplied
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Exact(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.time"/>.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.time"/> at which the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Exact(System.Single,System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.time"/> and repeatedly every <paramref name="repeatInterval"/> there after.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.time"/> at which the callback should be called.</param>
            <param name="repeatInterval">The interval in seconds to repeat the timer.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Seconds(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (scaled) seconds.
            </summary>
            <param name="seconds">The amount of seconds before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Minutes(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (scaled) minutes.
            </summary>
            <param name="minutes">The amount of minutes before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ExactUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.unscaledTime"/>.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.unscaledTime"/> at which the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ExactUnscaled(System.Single,System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.unscaledTime"/> and repeatedly every <paramref name="repeatInterval"/> there after.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.unscaledTime"/> at which the callback should be called.</param>
            <param name="repeatInterval">The interval in seconds to repeat the timer.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.SecondsUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (unscaled) seconds.
            </summary>
            <param name="seconds">The amount of seconds before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.MinutesUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (unscaled) minutes.
            </summary>
            <param name="minutes">The amount of minutes before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelScaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback)">
            <summary>
            Cancels all scaled timers for the given callback.
            </summary>
            <param name="callback">The callback of the timers to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelScaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32)">
            <summary>
            Cancels a scaled timer for the given callback with a specific id.
            </summary>
            <param name="callback">The callback of the timer to cancel.</param>
            <param name="id">The id of the timer to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelUnscaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback)">
            <summary>
            Cancels all unscaled timers for the given callback.
            </summary>
            <param name="callback">The callback of the timers to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelUnscaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32)">
            <summary>
            Cancels a unscaled timer for the given callback with a specific id.
            </summary>
            <param name="callback">The callback of the timer to cancel.</param>
            <param name="id">The id of the timer to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelAll">
            <summary>
            Cancels all (both scaled and unscaled) timers for all callbacks.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback">
            <summary>
            Defines a method to be used for timer events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback.OnTimesUp(System.Int32,System.Object)">
            <summary>
            Called when a timer is triggered (eg. after X amount of time).
            </summary>
            <param name="id">The id of the timer.</param>
            <param name="args">The supplied event args if supplied when the timer was scheduled.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.MainThreadDispatcher">
            <summary>
            A dispatcher for running actions on the main thread from other threads. 
            Useful for when you need to use the Unity API in your own threads, since most of the API requires to be run on the main thread.
            
            Initialize the dispatcher by running <see cref="M:Archon.SwissArmyLib.Utils.MainThreadDispatcher.Initialize"/> from the main thread (eg. a MonoBehaviour).
            After initialization you can enqueue actions to run via <see cref="M:Archon.SwissArmyLib.Utils.MainThreadDispatcher.Enqueue(System.Action)"/>. The actions will be run in the next Unity update loop.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.MainThreadDispatcher.IsMainThread">
            <summary>
            Checks whether the current thread is the main thread.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.MainThreadDispatcher.Initialize">
            <summary>
            Initializes the MainThreadDispatcher if not already done. 
            Make sure this is run from the main thread.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.MainThreadDispatcher.Enqueue(System.Action)">
            <summary>
            Enqueues the action to be run on the main thread instead of the active thread.
            </summary>
            <param name="action">The action to enqueue.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.UpdateLoop">
            <summary>
            Unity's update loops.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.BetterTime">
            <summary>
            A simple wrapper for Unity's <see cref="T:UnityEngine.Time"/> that caches values to avoid the marshal overhead of each call.
            
            The performance benefit is very small, but completely free.
            
            Only readonly <see cref="T:UnityEngine.Time"/> properties (except for <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.FixedDeltaTime"/>) are cached, but everything is wrapped anyway so you don't have to use multiple time classes.
            
            Since this is just a wrapper just refer to Unity's documentation about what each property does.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale">
            <summary>
            Gets or sets the scalar that is applied to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.Time"/>, <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.DeltaTime"/> etc.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FrameCount">
            <summary>
            Gets the total number of frames that have passed.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.Time">
            <summary>
            Gets the (scaled) time in seconds at the beginning of this frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.DeltaTime">
            <summary>
            Gets the difference in seconds since the last frame. (Scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.SmoothDeltaTime">
            <summary>
            Gets a smoothed out time difference in seconds since the last frame. (Scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.UnscaledDeltaTime">
            <summary>
            Gets the unscaled time difference in seconds since the last frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.UnscaledTime">
            <summary>
            Gets the unscaled time in seconds at the beginning of this frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedDeltaTime">
            <summary>
            Gets or sets the fixed time in seconds between FixedUpdate.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedTime">
            <summary>
            Gets the time that the latest FixedUpdate started. This is scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedUnscaledDeltaTime">
            <summary>
            Gets the unscaled time difference since the previous FixedUpdate.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedUnscaledTime">
            <summary>
            Gets the unscaled time that the latest FixedUpdate started. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.InFixedTimeStep">
            <summary>
            Gets whether we're inside a FixedUpdate at the moment.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.RealTimeSinceStartup">
            <summary>
            Gets the real time in seconds since the game started.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.TimeSinceLevelLoad">
            <summary>
            Gets the time since the last level was loaded.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.MaximumDeltaTime">
            <summary>
            Gets or sets the maximum time in seconds that a fixed timestep frame can take. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.MaximumParticleDeltaTime">
            <summary>
            Gets or sets the maximum time in seconds that a frame can spend on updating particles.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.CaptureFramerate">
            <summary>
            Slows game playback time to allow screenshots to be saved between frames.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute">
            <summary>
            Changes the ScriptExecutionOrder of a <see cref="T:UnityEngine.MonoBehaviour"/> if it's not already explicitly set (or if <see cref="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Forced"/> is true).
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Order">
            <summary>
            The order you want for the script to have.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Forced">
            <summary>
            Whether you want the order to be forcibly set and not just used as a default value.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Editor.ReadOnlyAttribute">
            <summary>
            Marks the field to be unchangable via the inspector.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ReadOnlyAttribute.OnlyWhilePlaying">
            <summary>
            Whether it should only be readonly during play mode.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Lazy`1">
            <summary>
            Provides support for lazy initialization.
            
            If you're on .NET 4.0 or higher you might want to use System.Lazy instead.
            </summary>
            <typeparam name="T">The type of the lazily initialized value.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Lazy`1.Value">
            <summary>
            Gets the lazily initialized value of this <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> instance.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Lazy`1.IsValueCreated">
            <summary>
            Gets whether the value has been initialized.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> class. 
            The default constructor will be used to create the lazily initialized value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> class. 
            The specified initialization function will be used.
            </summary>
            <param name="valueFactory">The function to use for producing the lazily initialized value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.ToString">
            <summary>
            Creates a string representation of <see cref="P:Archon.SwissArmyLib.Utils.Lazy`1.Value"/> property for this instance.
            </summary>
            <returns>The result of ToString() on the lazily initialized value.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.op_Explicit(Archon.SwissArmyLib.Utils.Lazy{`0})~`0">
            <summary>
            Explicitly casts the <paramref name="lazy"/> to its lazily initialized value.
            </summary>
            <param name="lazy"></param>
            <returns><see cref="P:Archon.SwissArmyLib.Utils.Lazy`1.Value"/></returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.ServiceLocator">
            <summary>
                A (somewhat) simple implementation of the service locator pattern.
                The ServiceLocator knows about MonoBehaviours and how to work with them.
                Creating scene-specific resolvers that only live as long as their respective scene is also supported.
                <remarks>
                    Please note that when you load a new scene, the MonoBehaviours in that scene will have their Awake()
                    method called before their scene becomes the active one. This means you can't rely on
                    SceneManager.GetActiveScene() to return the scene they're in, so you might want to use GameObject.scene
                    to specify which scene to register the resolver for.
                </remarks>
            </summary>
        </member>
        <member name="E:Archon.SwissArmyLib.Utils.ServiceLocator.GlobalReset">
            <summary>
                Called when the global resolvers are reset.
            </summary>
        </member>
        <member name="E:Archon.SwissArmyLib.Utils.ServiceLocator.SceneReset">
            <summary>
                Called when a scene's resolvers are reset.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1">
            <summary>
                Registers a concrete singleton of the given type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingleton``1">
            <summary>
                Registers a concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``1">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``2">
            <summary>
                Registers a concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingleton``2">
            <summary>
                Registers a concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``2">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1(``0)">
            <summary>
                Registers a specific instance to be a singleton for its concrete type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``2(``1)">
            <summary>
                Registers a specific instance to be a singleton for the abstract type.
            </summary>
            <typeparam name="TAbstract">The abstract ype that will be mapped to <typeparamref name="TConcrete"/>.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for its concrete type.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2(``1)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for the abstract type.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete"/>.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0,UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for its concrete type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
            <param name="scene">The scene to register the singleton type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2(``1,UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for the abstract type.
            </summary>
            <typeparam name="TAbstract">The abstract ype that will be mapped to <typeparamref name="TConcrete"/>.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
            <param name="scene">The scene to register the singleton type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1">
            <summary>
                Registers a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1">
            <summary>
                Registers scene-specific a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers scene-specific a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``2">
            <summary>
                Registers a concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1(System.Func{``0})">
            <summary>
                Registers a concrete transient type to return new instances of when <typeparamref name="T" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(System.Func{``0})">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when <typeparamref name="T" /> is
                resolved.
                The specified resolver will be used for producing the instances.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(System.Func{``0},UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when <typeparamref name="T" /> is
                resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``2(System.Func{``1})">
            <summary>
                Registers a concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(System.Func{``1})">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(System.Func{``1},UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.Resolve``1(System.Boolean)">
            <summary>
                Locates and returns a transient object or singleton of the specified type.
                Searches for a global object first, if nothing is found and <paramref name="includeActiveScene" /> is true then it
                searches for a scene specific resolver.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <param name="includeActiveScene">Whether to search for a scene specific resolver if a global one isn't found.</param>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1">
            <summary>
                Locates and returns a transient object or singleton of the specified type for the currently active scene.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Locates and returns a transient object or singleton of the specified type for the given scene.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegistered``1(System.Boolean)">
            <summary>
            Checks whether there's registered a resolver for a specific type.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <param name="includeActiveScene">Whether to search for a scene specific resolver if a global one isn't found.</param>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegisteredInScene``1">
            <summary>
            Checks whether there's registered a scene-specific resolver for a specific type in the currently active scene.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegisteredInScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
            Checks whether there's registered a scene-specific resolver for a specific type in the specified scene.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.Reset">
            <summary>
                Clears all resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetGlobal">
            <summary>
                Clears global resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScene">
            <summary>
                Clears the currently active scene's resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScene(UnityEngine.SceneManagement.Scene)">
            <summary>
                Clears a specific scene's resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScenes">
            <summary>
                Clears all scene specific resolvers for all scenes.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.ColorUtils">
            <summary>
            Utility methods for <see cref="T:UnityEngine.Color"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ColorUtils.ToHex(UnityEngine.Color)">
            <summary>
            Converts the given color to its equivalent hex color in the form of #RRGGBBAA (eg. #000000FF for opaque black).
            </summary>
            <param name="color">The color to convert.</param>
            <returns>The hex representation of <paramref name="color"/>.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ColorUtils.RichTextColor(System.String,UnityEngine.Color)">
            <summary>
            Wraps the supplied string in rich text color tags.
            </summary>
            <param name="text">The text to be colored.</param>
            <param name="color">The color to make the text.</param>
            <returns><paramref name="text"/> wrapped in color tags.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Extensions.ListExtensions">
            <summary>
            Extensions for List
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Extensions.ListExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Shuffles the list using FisherYates shuffle algorithm.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list to shuffle.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.BaseShake`1">
            <summary>
            Represents an object that can shake a value of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of value to be shaked.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.UnscaledTime">
            <summary>
            Gets or sets whether the shake should use <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Duration">
            <summary>
            Gets how long the shake last.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Frequency">
            <summary>
            Gets the frequency of the shake.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Amplitude">
            <summary>
            Gets the amplitude of the shake.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.NormalizedTime">
            <summary>
            Gets the shake's current progress in the range 0 to 1.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.IsDone">
            <summary>
            Gets whether the shake is done.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.StartTime">
            <summary>
            Gets or sets the time that the shake started.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.CurrentTime">
            <summary>
            Gets the current scaled or unscaled time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Start(System.Single,System.Int32,System.Single)">
            <summary>
            Starts (or restarts) the shake with new parameters.
            </summary>
            <param name="amplitude">Amplitude of the new shake.</param>
            <param name="frequency">Frequency of the new shake.</param>
            <param name="duration">Duration of the new shake.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.GetAmplitude">
            <summary>
            Gets the amplitude at the current time.
            </summary>
            <returns>The current amplitude.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.GetAmplitude(System.Single)">
            <summary>
            Gets the amplitude at a specific (normalized) time.
            </summary>
            <param name="t">The normalized time to get the amplitude for (0-1)</param>
            <returns>The amplitude at the specific time.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.Shake">
            <summary>
            An object that can shake a float over time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake.Start(System.Single,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake.GetAmplitude(System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.Shake2D">
            <summary>
            An object that can shake a <see cref="T:UnityEngine.Vector2"/> over time.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Shake.Shake2D.Horizontal">
            <summary>
            The shake used for shaking the <see cref="F:UnityEngine.Vector2.x"/> value of the <see cref="T:UnityEngine.Vector2"/>.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Shake.Shake2D.Vertical">
            <summary>
            The shake used for shaking the <see cref="F:UnityEngine.Vector2.y"/> value of the <see cref="T:UnityEngine.Vector2"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake2D.Start(System.Single,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake2D.GetAmplitude(System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalEntity">
            <summary>
            Makes this <see cref="T:UnityEngine.GameObject"/>'s <see cref="T:UnityEngine.Rigidbody"/> part of the gravitational system.
            
            For 2D physics see <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D"/>.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.IGravitationalAffecter">
            <summary>
            Represents a gravitational pull on entities.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.IGravitationalAffecter.GetForceAt(UnityEngine.Vector3)">
            <summary>
            Calculates how much gravitational pull is at a specific location caused by this affecter.
            </summary>
            <param name="location">The location to test.</param>
            <returns>A vector representing the force at <paramref name="location"/>.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint">
            <summary>
            A sphere-shaped gravitational point.
            
            <remarks>The force is currently constant and not dependent on how close the entities are.</remarks>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.Strength">
            <summary>
            The gravitational pull of this point.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.Radius">
            <summary>
            Gets or sets the radius of this gravitational point.
            
            <remarks>If <see cref="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.IsGlobal"/> is true, then this property is ignored.</remarks>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.DropoffCurve">
            <summary>
            Gets or sets the dropoff curve of the gravitational force.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.IsGlobal">
            <summary>
            Gets or sets whether this point should affect all entities regardless of whether they're in range.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.GetForceAt(UnityEngine.Vector3)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D">
            <summary>
            Makes this <see cref="T:UnityEngine.GameObject"/>'s <see cref="T:UnityEngine.Rigidbody2D"/> part of the gravitational system.
            
            For 3D physics see <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity"/>.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalSystem">
            <summary>
            A gravitational system to allow for a more flexible gravity instead of just a constant directional gravity.
            
            Useful for planets, black holes, magnets etc.
            
            Rigidbodies that should be affected should have the <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity"/> component (or <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D"/> if using 2d physics).
            
            Add gravitational forces by implementing the <see cref="T:Archon.SwissArmyLib.Gravity.IGravitationalAffecter"/> interface and registering it in the system.
            See <see cref="T:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint"/> for a simple example implementation.
            
            <remarks>You might want to set Unity's gravity to (0,0,0).</remarks>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(Archon.SwissArmyLib.Gravity.IGravitationalAffecter)">
            <summary>
            Registers a gravitational affecter to be part of the system.
            </summary>
            <param name="affecter">The affecter to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(UnityEngine.Rigidbody)">
            <summary>
            Registers a <see cref="T:UnityEngine.Rigidbody"/> that should be affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(UnityEngine.Rigidbody2D)">
            <summary>
            Registers a <see cref="T:UnityEngine.Rigidbody2D"/> that should be affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(Archon.SwissArmyLib.Gravity.IGravitationalAffecter)">
            <summary>
            Unregisters a gravitational affecter from the system, so it no longer affects entities.
            </summary>
            <param name="affecter">The affecter to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(UnityEngine.Rigidbody)">
            <summary>
            Unregisters a <see cref="T:UnityEngine.Rigidbody"/> from the system, so it no longer is affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(UnityEngine.Rigidbody2D)">
            <summary>
            Unregisters a <see cref="T:UnityEngine.Rigidbody2D"/> from the system, so it no longer is affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.GetGravityAtPoint(UnityEngine.Vector3)">
            <summary>
            Gets the sum of all gravitational forces at a specific location.
            </summary>
            <param name="location">The location to test.</param>
            <returns>A vector representing the sum of gravitational force at <paramref name="location"/>.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Bin2D`1">
            <summary>
            A simple GC-friendly two-dimensional <see href="https://en.wikipedia.org/wiki/Bin_(computational_geometry)">Bin (aka Spatial Grid)</see> implementation.
            
            When you're done with the Bin, you should <see cref="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Dispose"/> it so its resources can be freed in their object pool. If you forget this, no harm will be done but memory will be GC'ed.
            
            <seealso cref="T:Archon.SwissArmyLib.Partitioning.Bin3D`1"/>
            </summary>
            <typeparam name="T">The type of items this Bin will hold.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Width">
            <summary>
            Gets the width (number of columns) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Height">
            <summary>
            Gets the height (number of rows) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.CellWidth">
            <summary>
            Gets the width of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.CellHeight">
            <summary>
            Gets the height of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Origin">
            <summary>
            The coordinate at which this bin's bottom left corner lies.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> for the items in the given cell.
            </summary>
            <param name="x">The x coordinate of the cell.</param>
            <param name="y">The y coordinate of the cell.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.#ctor(System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.#ctor(System.Int32,System.Int32,System.Single,System.Single,UnityEngine.Vector2)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
            <param name="origin">The coordinate of the bottom left point of the grid.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Insert(`0,UnityEngine.Rect)">
            <summary>
            Inserts an item with the given bounds into the Bin.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Remove(`0)">
            <summary>
            Goes through all cells and removes the specified item if they contain it.
            If you can you should use <see cref="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Remove(`0,UnityEngine.Rect)"/> instead.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Remove(`0,UnityEngine.Rect)">
            <summary>
            Removes an item which was inserted with the given bounds from the Bin.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds that the item was inserted with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Update(`0,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>
            Removes and reinserts an item with new bounds, essentially moving it.
            </summary>
            <param name="item">The item to update.</param>
            <param name="prevBounds">The bounds that the item was inserted with earlier.</param>
            <param name="newBounds">The new bounds to insert the item with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})">
            <summary>
            Gets all items in the Bin that could potentially intersect with the given bounds.
            </summary>
            <param name="bounds">The bounds to check for.</param>
            <param name="results">Where to add results to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Clear">
            <summary>
            Removes all items from the Bin.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Dispose">
            <summary>
            Frees (clears) used resources that can be recycled. 
            
            Call this when you're done with the Bin.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Bin3D`1">
            <summary>
            A simple GC-friendly three-dimensional <see href="https://en.wikipedia.org/wiki/Bin_(computational_geometry)">Bin (aka Spatial Grid)</see> implementation.
            
            When you're done with the Bin, you should <see cref="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Dispose"/> it so its resources can be freed in their object pool. If you forget this, no harm will be done but memory will be GC'ed.
            
            <seealso cref="T:Archon.SwissArmyLib.Partitioning.Bin2D`1"/>
            </summary>
            <typeparam name="T">The type of items this Bin will hold.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Width">
            <summary>
            Gets the width (number of columns) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Height">
            <summary>
            Gets the height (number of rows) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Depth">
            <summary>
            Gets the depth (number of layers) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellWidth">
            <summary>
            Gets the width of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellHeight">
            <summary>
            Gets the height of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellDepth">
            <summary>
            Gets the depth of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Origin">
            <summary>
            The coordinate at which this bin's bottom left front corner lies.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> for the items in the given cell.
            </summary>
            <param name="x">The x coordinate of the cell.</param>
            <param name="y">The y coordinate of the cell.</param>
            <param name="z">The z coordinate of the cell.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="gridDepth">The depth of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
            <param name="cellDepth">The depth of a cell.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single,UnityEngine.Vector3)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="gridDepth">The depth of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
            <param name="cellDepth">The depth of a cell.</param>
            <param name="origin">The coordinate of the bottom left front point of the grid.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Insert(`0,UnityEngine.Bounds)">
            <summary>
            Inserts an item with the given bounds into the Bin.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Remove(`0,UnityEngine.Bounds)">
            <summary>
            Removes an item which was inserted with the given bounds from the Bin.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds that the item was inserted with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Remove(`0)">
            <summary>
            Goes through all cells and removes the specified item if they contain it.
            If you can you should use <see cref="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Remove(`0,UnityEngine.Bounds)"/> instead.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Update(`0,UnityEngine.Bounds,UnityEngine.Bounds)">
            <summary>
            Removes and reinserts an item with new bounds, essentially moving it.
            </summary>
            <param name="item">The item to update.</param>
            <param name="prevBounds">The bounds that the item was inserted with earlier.</param>
            <param name="newBounds">The new bounds to insert the item with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})">
            <summary>
            Gets all items in the Bin that could potentially intersect with the given bounds.
            </summary>
            <param name="bounds">The bounds to check for.</param>
            <param name="results">Where to add results to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Clear">
            <summary>
            Removes all items from the Bin.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Dispose">
            <summary>
            Frees (clears) used resources that can be recycled. 
            
            Call this when you're done with the Bin.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Octree`1">
            <summary>
            A GC-friendly <see href="https://en.wikipedia.org/wiki/Octree">Octree</see> implementation.
            
            Use the static <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Create(UnityEngine.Bounds,System.Int32,System.Int32)"/> and <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/> methods for creating and destroying trees.
            If you forget to <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/> a tree when you're done with it, it will instead be collected 
            by the GC as normal, but the nodes will not be recycled.
            </summary>
            <typeparam name="T">The type of items this octree should hold.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Create(UnityEngine.Bounds,System.Int32,System.Int32)">
            <summary>
            Creates an Octree.
            </summary>
            <param name="bounds">The size of the tree's bounds.</param>
            <param name="maxItems">The amount of items a node can contain before splitting.</param>
            <param name="maxDepth">The maximum depth</param>
            <returns>The octree.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})">
            <summary>
            Destroys a tree, making it available for being recycled.
            
            Do not use the tree again after calling this.
            </summary>
            <param name="tree">The tree to destroy.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds">
            <summary>
            Gets the bounds of this octree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Depth">
            <summary>
            Gets the depth of this octree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.MaxDepth">
            <summary>
            Gets the maximum depth that the octree can go.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.MaxItems">
            <summary>
            Gets the maximum amount of items this node can contain before splitting.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.IsSplit">
            <summary>
            Gets whether this node has been split.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Count">
            <summary>
            Gets the total amount of items from this node and down.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Insert(`0,UnityEngine.Bounds)">
            <summary>
            Inserts an item with the specified bounds into the octree.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item, used to place it correctly in the tree.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Remove(`0,UnityEngine.Bounds)">
            <summary>
            Removes an item with the specified bounds from the octree.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds used for previously inserting this item.</param>
            <returns>True if item was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds)">
            <summary>
            Retrieves all potential matches for the given <see cref="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds"/>.
            
            Careful, this method creates a new <see cref="T:System.Collections.Generic.HashSet`1"/>. 
            You might want to use <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})"/> instead if you call this often.
            </summary>
            <param name="bounds"></param>
            <returns>Potential matches.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})">
            <summary>
            Retrieves all potential matches for the given <see cref="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds"/> and adds them to <paramref name="results"/>.
            </summary>
            <param name="bounds"></param>
            <param name="results">Where results will be added to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Clear">
            <summary>
            Clears all items in this node and removes subnodes.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Dispose">
            <summary>
            Destroys the octree using <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/>.
            
            Do not use the tree after calling this!
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Quadtree`1">
            <summary>
            A GC-friendly <see href="https://en.wikipedia.org/wiki/Quadtree">Quadtree</see> implementation.
            
            Use the static <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Create(UnityEngine.Rect,System.Int32,System.Int32)"/> and <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/> methods for creating and destroying trees.
            If you forget to <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/> a tree when you're done with it, it will instead be collected 
            by the GC as normal, but the nodes will not be recycled.
            </summary>
            <typeparam name="T">The type of items this quadtree should hold.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Create(UnityEngine.Rect,System.Int32,System.Int32)">
            <summary>
            Creates a Quadtree.
            </summary>
            <param name="bounds">The size of the tree's bounds.</param>
            <param name="maxItems">The amount of items a node can contain before splitting.</param>
            <param name="maxDepth">The maximum depth</param>
            <returns>The quadtree.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})">
            <summary>
            Destroys a tree, making it available for being recycled.
            
            Do not use the tree again after calling this.
            </summary>
            <param name="tree">The tree to destroy.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Bounds">
            <summary>
            Gets the bounds of this quadtree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Depth">
            <summary>
            Gets the depth of this quadtree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.MaxDepth">
            <summary>
            Gets the maximum depth that the quadtree can go.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.MaxItems">
            <summary>
            Gets the maximum amount of items this node can contain before splitting.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.IsSplit">
            <summary>
            Gets whether this node has been split.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Count">
            <summary>
            Gets the total amount of items from this node and down.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Insert(`0,UnityEngine.Rect)">
            <summary>
            Inserts an item with the specified bounds into the quadtree.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item, used to place it correctly in the tree.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Remove(`0,UnityEngine.Rect)">
            <summary>
            Removes an item with the specified bounds from the quadtree.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds used for previously inserting this item.</param>
            <returns>True if item was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect)">
            <summary>
            Retrieves all potential matches for the given <see cref="T:UnityEngine.Rect"/>.
            
            Careful, this method creates a new <see cref="T:System.Collections.Generic.HashSet`1"/>. 
            You might want to use <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})"/> instead if you call this often.
            </summary>
            <param name="rect"></param>
            <returns>Potential matches.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})">
            <summary>
            Retrieves all potential matches for the given <see cref="T:UnityEngine.Rect"/> and adds them to <paramref name="results"/>.
            </summary>
            <param name="rect"></param>
            <param name="results">Where results will be added to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Clear">
            <summary>
            Clears all items in this node and removes subnodes.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Dispose">
            <summary>
            Destroys the quadtree using <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/>.
            
            Do not use the tree after calling this!
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolableGroup">
            <summary>
            Manages a list of IPoolable components found in the hierarchy of this GameObject and notifies them when it is spawned and despawned.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolableGroup.AddManually``1(``0)">
            <summary>
            Manually add a poolable object to be notified when this component is spawned or despawned.
            
            Useful if you dynamically add IPoolable components at runtime.
            </summary>
            <param name="poolable">The poolable object that should be notified.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolableGroup.RemoveManually``1(``0)">
            <summary>
            Manually removes a poolable object so that it no longer is notified when this component is spawned or despawned.
            </summary>
            <param name="poolable">The poolable object that should no longer be notified.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.GameObjectPool`1">
            <summary>
            An object pool that can recycle prefab instances.
            </summary>
            <typeparam name="T">The type of the component on the prefab.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Prefab">
            <summary>
            Gets the prefab used to instantiate GameObjects.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.#ctor(`0,System.Boolean)">
            <summary>
            Creates a new GameObject pool for the specified prefab.
            </summary>
            <param name="prefab">The prefab used for instantiating instances.</param>
            <param name="multiScene">Should the pool and its contents survive a scene change?</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.#ctor(System.String,System.Func{`0},System.Boolean)">
            <summary>
            Creates a new GameObject pool with a custom name and a factory method used for instantiating instances.
            </summary>
            <param name="name">The name of the pool.</param>
            <param name="create">The factory method used to instantiating instances.</param>
            <param name="multiScene">Should the pool and its contents survive a scene change?</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Finalize">
            <summary>
            Destructor.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Dispose">
            <summary>
            Destroys the pool and any despawned objects in it.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.SpawnInternal">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn(UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn(UnityEngine.Vector3)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn(UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Despawn(`0)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.OnSpawned(`0)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.IPool`1">
            <summary>
            Represents an object pool that has methods for spawning and despawning objects.
            </summary>
            <typeparam name="T">The type of objects that this pool can be used for.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPool`1.Spawn">
            <summary>
            Spawns a recycled or new instance of the type <typeparamref name="T"/>.
            </summary>
            <returns>The spawned instance.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPool`1.Despawn(`0)">
            <summary>
            Despawns an instance of the type <typeparamref name="T"/> and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.IPoolable">
            <summary>
            Represents an object that can be recycled in an <see cref="T:Archon.SwissArmyLib.Pooling.IPool`1"/> and should be notified when it's spawned and despawned.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPoolable.OnSpawned">
            <summary>
            Called when the object is spawned (either fresh or recycled).
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPoolable.OnDespawned">
            <summary>
            Called when the object is despawned and marked for recycling.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.Pool`1">
            <summary>
            An object pool that can recycle objects of the type <typeparamref name="T"/>.
            
            If the type implements <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            </summary>
            <typeparam name="T">The type of objects this object pool should contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Pooling.Pool`1.FreeCount">
            <summary>
            Gets the current amount of free instances in the pool.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Pooling.Pool`1.Free">
            <summary>
            Contains the items ready to be reused.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new object pool that uses the specified factory method to create object instances.
            </summary>
            <param name="create">Factory method to use for creating new instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Prewarm(System.Int32)">
            <summary>
            Fills the pool with objects so that it contains the specified amount of objects.
            
            If it already contains the specified amount or more, nothing will be done.
            </summary>
            <param name="targetCount"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Spawn">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.SpawnInternal">
            <summary>
            Recycles or creates a object if there's one available without calling <see cref="M:Archon.SwissArmyLib.Pooling.Pool`1.OnSpawned(`0)"/>.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Despawn(`0)">
            <summary>
            Despawns an object, adding it back to the pool.
            </summary>
            <param name="target">The object to despawn.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.OnSpawned(`0)">
            <summary>
            Called when an object has been spawned and removed from the pool.
            </summary>
            <param name="target">The spawned object.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.OnDespawned(`0)">
            <summary>
            Called when an object has been despawned and placed back in the pool.
            </summary>
            <param name="target">The despawned object.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Despawn(`0,System.Single,System.Boolean)">
            <summary>
            Despawns an object after a delay.
            </summary>
            <param name="target">The target to despawn.</param>
            <param name="delay">Time in seconds to wait before despawning the target.</param>
            <param name="unscaledTime">Should the delay be according to <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>?</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.CancelDespawn(`0)">
            <summary>
            Cancels a pending timed despawn.
            </summary>
            <param name="target">The target that shouldn't despawn after all.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolHelper">
            <summary>
            Simple static helper class for pooling Unity prefab instances.
            
            If the pooled objects implement <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            
            For non-Unity objects see <see cref="T:Archon.SwissArmyLib.Pooling.PoolHelper`1"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0,UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0,UnityEngine.Vector3)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Despawn(UnityEngine.Object)">
            <summary>
            Despawns an instance and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Despawn(UnityEngine.Object,System.Single,System.Boolean)">
            <summary>
            Despawns an instance after a delay.
            </summary>
            <param name="target">The instance to despawn.</param>
            <param name="delay">Time in seconds to wait before despawning the target.</param>
            <param name="unscaledTime">Should the delay be according to <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>?</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetFreeCount(UnityEngine.Object)">
            <summary>
            Gets the amount of free instances in the pool for the specified prefab.
            </summary>
            <returns>The amount of free instances in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPrefab(UnityEngine.Object)">
            <summary>
            Gets the prefab that was used to spawn <paramref name="instance"/>.
            </summary>
            <param name="instance">The instance to get the prefab for.</param>
            <returns>The prefab for the instance, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPrefab``1(``0)">
            <summary>
            Gets the prefab that was used to spawn <paramref name="instance"/>.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="instance">The instance to get the prefab for.</param>
            <returns>The prefab for the instance, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPool(UnityEngine.Object)">
            <summary>
            Gets or creates the pool for the given prefab.
            </summary>
            <param name="prefab">The prefab to get a pool for.</param>
            <returns>The pool for the prefab.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolHelper`1">
            <summary>
            Simple static helper class for pooling non-Unity objects.
            
            If the pooled objects implement <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            
            For Unity GameObjects see <see cref="T:Archon.SwissArmyLib.Pooling.PoolHelper"/>.
            </summary>
            <typeparam name="T">The type of the object to pool.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Pooling.PoolHelper`1.FreeCount">
            <summary>
            Gets the amount of free instances in the pool.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper`1.Spawn">
            <summary>
            Spawns a recycled or new instance of the type <typeparamref name="T"/>.
            </summary>
            <returns>The spawned instance.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper`1.Despawn(`0)">
            <summary>
            Despawns an instance of the type <typeparamref name="T"/> and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper`1.Despawn(`0,System.Single,System.Boolean)">
            <summary>
            Despawns an object after a delay.
            </summary>
            <param name="target">The target to despawn.</param>
            <param name="delay">Time in seconds to wait before despawning the target.</param>
            <param name="unscaledTime">Should the delay be according to <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>?</param>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent`2.OriginalDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent`2.ModifiedDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent`2.AppliedDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent`2.Source">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent`2.Args">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent`2">
            <summary>
            Defines an event for after a resource pool has been changed.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent`2.OriginalDelta">
            <summary>
            Gets the originally requested resource change.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent`2.ModifiedDelta">
            <summary>
            Gets the modified delta after listeners of <see cref="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnPreChange"/> had their chance to affect it.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent`2.AppliedDelta">
            <summary>
            Gets the actual applied (and clamped) delta. 
            Basically just the difference in resource amount before and after the change.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent`2">
            <summary>
            Defines a change event that has not yet happened, and can be altered.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent`2.OriginalDelta">
            <summary>
            Gets the originally requested resource change.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent`2.ModifiedDelta">
            <summary>
            Gets or sets the modified delta that will be applied after this event.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourceEvent`2">
            <summary>
            Defines a barebones resource event.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceEvent`2.Source">
            <summary>
            Gets or sets the source of the resource change.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceEvent`2.Args">
            <summary>
            Gets or sets the args that the sender sent with the change.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool">
            <summary>
            A flexible resource pool (eg. health, mana, energy).
            
            If you need type-safety consider subclassing the generic version: <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2"/>.
            
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen"/>
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.Shield"/>
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2">
            <summary>
            A flexible resource pool (eg. health, mana, energy).
            
            Generic version of <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/> in case you want type-safety. 
            To be able to use this you should make a non-generic subclass.
            
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen"/>
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.Shield"/>
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EventIds">
            <summary>
            Event ids for resource change events.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnPreChange">
            <summary>
            Event called just before the resource amount is changed. 
            You can affect the applied change by modifying <see cref="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent`2.ModifiedDelta"/>.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnChange">
            <summary>
            Event called after the resource amount has been changed.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnEmpty">
            <summary>
            Event called once the pool has been completely emptied.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnFull">
            <summary>
            Event called when the pool has been completely filled.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.OnRenew">
            <summary>
            Event called when the pool is renewed using <see cref="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(`0,`1,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Current">
            <summary>
            Gets the current amount of resource in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Max">
            <summary>
            Gets or sets the maximum amount of source that can be in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed">
            <summary>
            Gets or sets whether adding resource should be disabled after the pool is completely empty, until it is renewed using <see cref="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(`0,`1,System.Boolean)"/> again.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Percentage">
            <summary>
            Gets a how full the resource is percentage-wise (0 to 1)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.IsEmpty">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.IsFull">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.TimeSinceEmpty">
            <summary>
            Get the (scaled) time since this pool was last empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.DefaultSource">
            <summary>
            Gets the source to fallback on if no source is specified.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.DefaultArgs">
            <summary>
            Gets the args to fallback on if no args is specified.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Awake">
            <summary>
            Called when the MonoBehaviour is added to a GameObject.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Add(System.Single,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Add(System.Single,`0,System.Boolean)">
            <summary>
            Adds the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to add.</param>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Add(System.Single,`0,`1,System.Boolean)">
            <summary>
            Adds the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to add.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Remove(System.Single,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Remove(System.Single,`0,System.Boolean)">
            <summary>
            Removes the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to remove.</param>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Remove(System.Single,`0,`1,System.Boolean)">
            <summary>
            Removes the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to remove.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Empty(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Empty(`0,System.Boolean)">
            <summary>
            Completely empties the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Empty(`0,`1,System.Boolean)">
            <summary>
            Completely empties the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(`0,System.Boolean)">
            <summary>
            Fully fills the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(`0,`1,System.Boolean)">
            <summary>
            Fully fills the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(System.Single,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(System.Single,`0,System.Boolean)">
            <summary>
            Fills the pool to the specified amount.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Fill(System.Single,`0,`1,System.Boolean)">
            <summary>
            Fills the pool to the specified amount.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(`0,System.Boolean)">
            <summary>
            Fully restores the pool, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(`0,`1,System.Boolean)">
            <summary>
            Fully restores the pool, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(System.Single,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(System.Single,`0,System.Boolean)">
            <summary>
            Restores the pool to the specified amount, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Renew(System.Single,`0,`1,System.Boolean)">
            <summary>
            Restores the pool to the specified amount, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.Change(System.Single,`0,`1,System.Boolean)">
            <summary>
            Changes the resource amount by <paramref name="delta"/>.
            </summary>
            <param name="delta">The delta to apply.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase">
            <summary>
            Non-generic base class for <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/> to allow its editor to work for subclasses.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Current">
            <summary>
            Gets the current amount of resource in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Max">
            <summary>
            Gets or sets the maximum amount of source that can be in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.EmptyTillRenewed">
            <summary>
            Gets or sets whether adding resource should be disabled after the pool is completely empty, until it is renewed again.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Percentage">
            <summary>
            Gets a how full the resource is percentage-wise (0 to 1)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.IsEmpty">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.IsFull">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.TimeSinceEmpty">
            <summary>
            Get the (scaled) time since this pool was last empty.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Add(System.Single,System.Boolean)">
            <summary>
            Adds the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to add.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Remove(System.Single,System.Boolean)">
            <summary>
            Removes the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to remove.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Empty(System.Boolean)">
            <summary>
            Completely empties the pool.
            </summary>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Fill(System.Boolean)">
            <summary>
            Fully fills the pool.
            </summary>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Fill(System.Single,System.Boolean)">
            <summary>
            Fills the pool to the specified amount.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Renew(System.Boolean)">
            <summary>
            Fully restores the pool, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePoolBase.Renew(System.Single,System.Boolean)">
            <summary>
            Restores the pool to the specified amount, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2.EmptyTillRenewed"/>.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen">
            <summary>
            Adds resource to a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/> at a constant rate or in intervals.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Target"/> is not set, it will try to find a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool" /> on the same GameObject.
            
            If you need type-safety consider subclassing the generic version: <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2"/>.
            
            <remarks>
                This non-generic version only works for the non-generic <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/>.
            </remarks>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Awake">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2">
            <summary>
            Adds resource to a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2"/> at a constant rate or in intervals.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Target"/> is not set, it will try to find a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2" /> on the same GameObject.
            
            Generic version of <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen"/> in case you want type-safety. 
            To be able to use this you should make a non-generic subclass.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Interval">
            <summary>
            Gets or sets how often in seconds that <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.AmountPerInterval"/> resources should be gained.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.AmountPerInterval">
            <summary>
            Gets or sets the amount of resource that should be gained every <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Interval"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.ConstantAmountPerSecond">
            <summary>
            Gets or sets the amount of resource that should be gained per second.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.DownTimeOnResourceLoss">
            <summary>
            Gets or sets the amount of time in seconds to stop healing after the <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Target"/> loses resource.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Target">
            <summary>
            Gets or sets the target <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/> that should regen.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Awake">
            <summary>
            Called when the MonoBehaviour is added to a GameObject.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.OnEnable">
            <summary>
            Called when the MonoBehaviour is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.OnDisable">
            <summary>
            Called when the MonoBehaviour is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen`2.Update">
            <summary>
            Called every frame.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.Shield">
            <summary>
            A resource pool that is used to protect another resource pool from getting drained. 
            The shield intercepts the event and applies some of the change to itself, only letting part (or none at all) of the change get through.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.ProtectedTarget"/> is not set, it will try to find a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool" /> on the same GameObject.
            
            If you need type-safety consider subclassing the generic version: <see cref="T:Archon.SwissArmyLib.ResourceSystem.Shield`2"/>.
            
            <remarks>
                This non-generic version only works for the non-generic <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/>.
            </remarks>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.Awake">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.Shield`2">
            <summary>
            A resource pool that is used to protect another resource pool from getting drained. 
            The shield intercepts the event and applies some of the change to itself, only letting part (or none at all) of the change get through.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.ProtectedTarget"/> is not set, it will try to find a <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool`2"/> on the same GameObject.
            
            Generic version of <see cref="T:Archon.SwissArmyLib.ResourceSystem.Shield"/> in case you want type-safety. 
            To be able to use this you should make a non-generic subclass.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.ProtectedTarget">
            <summary>
            Gets or sets the target that this shield should protect.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.AbsorptionFlat">
            <summary>
            Gets or sets the flat amount of removed resource that should be absorbed by the shield.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.AbsorptionScaling">
            <summary>
            Gets or sets the fraction of removed resource that should be absorbed by the shield.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.EmptiesWithTarget">
            <summary>
            Gets or sets whether the shield should get fully drained when the target is empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield`2.RenewsWithTarget">
            <summary>
            Gets or sets whether the shield should renew when the target does.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.Awake">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.OnEnable">
            <summary>
            Called when the MonoBehaviour is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.OnDisable">
            <summary>
            Called when the MonoBehaviour is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.Change(System.Single,`0,`1,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.OnEvent(System.Int32,Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.OnEvent(System.Int32,Archon.SwissArmyLib.ResourceSystem.IResourceEvent{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield`2.GetDefaultTarget">
            <summary>
            Attempts to find a different resource pool on this GameObject.
            </summary>
            <returns>The found pool, or null if none were found.</returns>
        </member>
    </members>
</doc>
